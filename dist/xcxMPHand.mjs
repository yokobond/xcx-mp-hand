import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';

var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAHwCAYAAABe0QtuAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAIABJREFUeJzs3el3HNl5Jvgnct837ARIACS4k0WyyGKxdkklyVpKcmlrWe1un3HPmZkzf8Sc0/9Cf5w5/UHj9tgtyZIlWbZkbaVauRRZZHFfQRL7lpnIRO6ZETEfKEgsFkDEjYgbGQk8v0/dVmTGJchKxJP3vu+rNPT/poOIiIiIiMgBnnYvgIiIiIiItg4GECIiIiIicgwDCBEREREROYYBhIiIiIiIHMMAQkREREREjmEAISIiIiIixzCAEBERERGRYxhAiIiIiIjIMQwgRERERETkGAYQIiIiIiJyDAMIERERERE5hgGEiIiIiIgcwwBCRERERESOYQAhIiIiIiLHMIAQEREREZFjGECIiIiIiMgxDCBEREREROQYBhAiIiIiInIMAwgRERERETmGAYSIiIiIiBzDAEJERERERI5hACEiIiIiIscwgBARERERkWMYQIiIiIiIyDEMIERERERE5BgGECIiIiIicgwDCBEREREROYYBhIiIiIiIHMMAQkREREREjmEAISIiIiIixzCAEBERERGRYxhAiIiIiIjIMQwgRERERETkGAYQIiIiIiJyDAMIERERERE5hgGEiIiIiIgcwwBCRERERESOYQAhIiIiIiLHMIAQEREREZFjGECIiIiIiMgxDCBEREREROQYBhAiIiIiInIMAwgRERERETmGAYSIiIiIiBzDAEJERERERI5hACEiIiIiIscwgBARERERkWMYQIiIiIiIyDEMIERERERE5BgGECIiIiIicgwDCBEREREROYYBhIiIiIiIHMMAQkREREREjmEAISIiIiIixzCAEBERERGRYxhAiIiIiIjIMQwgRERERETkGAYQIiIiIiJyDAMIERERERE5hgGEiIiIiIgcwwBCRERERESOYQAhIiIiIiLHMIAQEREREZFjGECIiIiIiMgxDCBEREREROQYBhAiIiIiInIMAwgRERERETmGAYSIiIiIiBzDAEJERERERI5hACEiIiIiIscwgBARERERkWMYQIiIiIiIyDEMIERERERE5BgGECIiIiIicgwDCBEREREROYYBhIiIiIiI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AACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAWJoQDAAAAPFJREFUAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAYwggAAAAAIwhgAAAAAAwhgACAAAAwBgCCAAAAABjCCAAAAAAjCGAAAAAADCGAAIAAADAGAIIAAAAAGMIIAAAAACMIYAAAAAAMIYAAgAAAMAYAggAAAAAY/4fjU9mq26dAWwAAAAASUVORK5CYII=";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!-- Created with Inkscape (http://www.inkscape.org/) --%3e%3csvg version='1.1' id='svg1' width='53' height='53' viewBox='0 0 53 53' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg'%3e %3cdefs id='defs1' /%3e %3cg id='g34' transform='matrix(0.42836814%2c0%2c0%2c0.42836814%2c-78.78756%2c-109.22759)' style='display:inline'%3e %3cg id='g22'%3e %3cpath style='display:inline%3bfill:none%3bfill-opacity:1%3bstroke:%23bedcff%3bstroke-width:24.1611%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 215.97233%2c329.43129 5.17617%2c19.19999 25.14497%2c13.12102 19.63717%2c-4.01278 23.83526%2c-40.01856 v 0 0' id='path16' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%23bedcff%3bstroke-width:24.1611%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='M 246.29347%2c361.7523 215.97233%2c329.43129 197.38376%2c296.06433' id='path17' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%23bedcff%3bstroke-width:24.1611%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 231.90723%2c272.70274 4.42547%2c30.97354 9.96077%2c58.07602' id='path19' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%23bedcff%3bstroke-width:24.1611%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 263.0493%2c271.9437 0.47283%2c33.98523 -17.22866%2c55.82337 v 0' id='path20' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%23bedcff%3bstroke-width:24.1611%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 294.19136%2c288.43322 -4.42546%2c29.28774 -43.47243%2c44.03134' id='path21' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%23bedcff%3bstroke-width:24.1611%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 219.29973%2c334.83831 19.94444%2c-7.0384 17.20724%2c-14.80026 23.74822%2c13.0398' id='path22' /%3e %3c/g%3e %3cg id='g26' style='display:inline'%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%234a90e2%3bstroke-width:4.83222%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='M 246.29347%2c361.7523 215.97233%2c329.43129 197.38376%2c296.06433' id='path23' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%234a90e2%3bstroke-width:4.83222%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 231.90723%2c272.70274 4.42547%2c30.97354 9.96077%2c58.07602' id='path24' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%234a90e2%3bstroke-width:4.83222%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 263.0493%2c271.9437 0.47283%2c33.98523 -17.22866%2c55.82337 v 0' id='path25' /%3e %3cpath style='fill:none%3bfill-opacity:1%3bstroke:%234a90e2%3bstroke-width:4.83222%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none%3bstroke-opacity:1' d='m 294.19136%2c288.43322 -4.42546%2c29.28774 -43.47243%2c44.03134' id='path26' /%3e %3c/g%3e %3ccircle cx='193.77252' cy='363.5856' fill='%234a90e2' id='circle26' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='180.73982' cy='390.18457' fill='%234a90e2' id='circle27' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='126.03345' cy='419.09518' fill='%234a90e2' id='circle28' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='106.84238' cy='379.14868' fill='%234a90e2' id='circle29' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='99.154907' cy='341.73489' fill='%234a90e2' id='circle30' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='139.10776' cy='329.84357' fill='%234a90e2' id='circle31' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='134.00861' cy='360.71335' fill='%234a90e2' id='circle32' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='169.03508' cy='338.48996' fill='%234a90e2' id='circle33' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='159.26027' cy='371.04257' fill='%234a90e2' id='circle34' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3c/g%3e%3c/svg%3e";

var en$1 = {
	"xcxMPHand.entry.name": "MediaPipe Hand Detection",
	"xcxMPHand.entry.description": "Hand position estimation using machine learning. Using Google MediaPipe Hand Landmarker."
};
var ja$1 = {
	"xcxMPHand.entry.name": "MediaPipe Hand Detection",
	"xcxMPHand.entry.description": "機械学習によって手の位置を推定します。 Google MediaPipe Hand Landmarker を使用しています。"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"xcxMPHand.entry.name": "MediaPipe ハンド ディテクション",
	"xcxMPHand.entry.description": "きかいがくしゅう に よって て の いち を よそう します。 Google MediaPipe Landmarker を しよう しています。"
}
};

/**
 * This is an extension for Xcratch.
 */


/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'xcxMPHand.entry.name',
      defaultMessage: 'MediaPipe Hand Detection',
      description: 'name of the extension'
    });
  },
  extensionId: 'xcxMPHand',
  extensionURL: 'https://yokobond.github.io/xcx-mp-hand/dist/xcxMPHand.mjs',
  collaborator: 'yokobond',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      defaultMessage: 'Hand position estimation using machine learning.',
      description: 'Description for this extension',
      id: 'xcxMPHand.entry.description'
    });
  },
  tags: ['ai', 'hand', 'image', 'machine learning', 'ml', 'mediapipe', 'vision'],
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  helpLink: 'https://yokobond.github.io/xcx-mp-hand/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _typeof$1(o) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$1(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof$1(i) ? i : i + "";
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

/**
 * Types of block
 * @enum {string}
 */
var blockType;
var hasRequiredBlockType;
function requireBlockType() {
  if (hasRequiredBlockType) return blockType;
  hasRequiredBlockType = 1;
  var BlockType = {
    /**
     * Boolean reporter with hexagonal shape
     */
    BOOLEAN: 'Boolean',
    /**
     * A button (not an actual block) for some special action, like making a variable
     */
    BUTTON: 'button',
    /**
     * Command block
     */
    COMMAND: 'command',
    /**
     * Specialized command block which may or may not run a child branch
     * The thread continues with the next block whether or not a child branch ran.
     */
    CONDITIONAL: 'conditional',
    /**
     * Specialized hat block with no implementation function
     * This stack only runs if the corresponding event is emitted by other code.
     */
    EVENT: 'event',
    /**
     * Hat block which conditionally starts a block stack
     */
    HAT: 'hat',
    /**
     * Specialized command block which may or may not run a child branch
     * If a child branch runs, the thread evaluates the loop block again.
     */
    LOOP: 'loop',
    /**
     * General reporter with numeric or string value
     */
    REPORTER: 'reporter'
  };
  blockType = BlockType;
  return blockType;
}

var blockTypeExports = requireBlockType();
var BlockType = /*@__PURE__*/getDefaultExportFromCjs(blockTypeExports);

/**
 * Block argument types
 * @enum {string}
 */
var argumentType;
var hasRequiredArgumentType;
function requireArgumentType() {
  if (hasRequiredArgumentType) return argumentType;
  hasRequiredArgumentType = 1;
  var ArgumentType = {
    /**
     * Numeric value with angle picker
     */
    ANGLE: 'angle',
    /**
     * Boolean value with hexagonal placeholder
     */
    BOOLEAN: 'Boolean',
    /**
     * Numeric value with color picker
     */
    COLOR: 'color',
    /**
     * Numeric value with text field
     */
    NUMBER: 'number',
    /**
     * String value with text field
     */
    STRING: 'string',
    /**
     * String value with matrix field
     */
    MATRIX: 'matrix',
    /**
     * MIDI note number with note picker (piano) field
     */
    NOTE: 'note',
    /**
     * Inline image on block (as part of the label)
     */
    IMAGE: 'image'
  };
  argumentType = ArgumentType;
  return argumentType;
}

var argumentTypeExports = requireArgumentType();
var ArgumentType = /*@__PURE__*/getDefaultExportFromCjs(argumentTypeExports);

var color;
var hasRequiredColor;
function requireColor() {
  if (hasRequiredColor) return color;
  hasRequiredColor = 1;
  var Color = /*#__PURE__*/function () {
    function Color() {
      _classCallCheck(this, Color);
    }
    return _createClass(Color, null, [{
      key: "RGB_BLACK",
      get:
      /**
       * @typedef {object} RGBObject - An object representing a color in RGB format.
       * @property {number} r - the red component, in the range [0, 255].
       * @property {number} g - the green component, in the range [0, 255].
       * @property {number} b - the blue component, in the range [0, 255].
       */

      /**
       * @typedef {object} HSVObject - An object representing a color in HSV format.
       * @property {number} h - hue, in the range [0-359).
       * @property {number} s - saturation, in the range [0,1].
       * @property {number} v - value, in the range [0,1].
       */

      /** @type {RGBObject} */
      function get() {
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }

      /** @type {RGBObject} */
    }, {
      key: "RGB_WHITE",
      get: function get() {
        return {
          r: 255,
          g: 255,
          b: 255
        };
      }

      /**
       * Convert a Scratch decimal color to a hex string, #RRGGBB.
       * @param {number} decimal RGB color as a decimal.
       * @return {string} RGB color as #RRGGBB hex string.
       */
    }, {
      key: "decimalToHex",
      value: function decimalToHex(decimal) {
        if (decimal < 0) {
          decimal += 0xFFFFFF + 1;
        }
        var hex = Number(decimal).toString(16);
        hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
        return hex;
      }

      /**
       * Convert a Scratch decimal color to an RGB color object.
       * @param {number} decimal RGB color as decimal.
       * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       */
    }, {
      key: "decimalToRgb",
      value: function decimalToRgb(decimal) {
        var a = decimal >> 24 & 0xFF;
        var r = decimal >> 16 & 0xFF;
        var g = decimal >> 8 & 0xFF;
        var b = decimal & 0xFF;
        return {
          r: r,
          g: g,
          b: b,
          a: a > 0 ? a : 255
        };
      }

      /**
       * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
       * CC-BY-SA Tim Down:
       * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
       * @param {!string} hex Hex representation of the color.
       * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       */
    }, {
      key: "hexToRgb",
      value: function hexToRgb(hex) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      /**
       * Convert an RGB color object to a hex color.
       * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       * @return {!string} Hex representation of the color.
       */
    }, {
      key: "rgbToHex",
      value: function rgbToHex(rgb) {
        return Color.decimalToHex(Color.rgbToDecimal(rgb));
      }

      /**
       * Convert an RGB color object to a Scratch decimal color.
       * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       * @return {!number} Number representing the color.
       */
    }, {
      key: "rgbToDecimal",
      value: function rgbToDecimal(rgb) {
        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
      }

      /**
      * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
      * @param {!string} hex Hex representation of the color.
      * @return {!number} Number representing the color.
      */
    }, {
      key: "hexToDecimal",
      value: function hexToDecimal(hex) {
        return Color.rgbToDecimal(Color.hexToRgb(hex));
      }

      /**
       * Convert an HSV color to RGB format.
       * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
       * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       */
    }, {
      key: "hsvToRgb",
      value: function hsvToRgb(hsv) {
        var h = hsv.h % 360;
        if (h < 0) h += 360;
        var s = Math.max(0, Math.min(hsv.s, 1));
        var v = Math.max(0, Math.min(hsv.v, 1));
        var i = Math.floor(h / 60);
        var f = h / 60 - i;
        var p = v * (1 - s);
        var q = v * (1 - s * f);
        var t = v * (1 - s * (1 - f));
        var r;
        var g;
        var b;
        switch (i) {
          default:
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
        }
        return {
          r: Math.floor(r * 255),
          g: Math.floor(g * 255),
          b: Math.floor(b * 255)
        };
      }

      /**
       * Convert an RGB color to HSV format.
       * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
       * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
       */
    }, {
      key: "rgbToHsv",
      value: function rgbToHsv(rgb) {
        var r = rgb.r / 255;
        var g = rgb.g / 255;
        var b = rgb.b / 255;
        var x = Math.min(Math.min(r, g), b);
        var v = Math.max(Math.max(r, g), b);

        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
        var h = 0;
        var s = 0;
        if (x !== v) {
          var f = r === x ? g - b : g === x ? b - r : r - g;
          var i = r === x ? 3 : g === x ? 5 : 1;
          h = (i - f / (v - x)) * 60 % 360;
          s = (v - x) / v;
        }
        return {
          h: h,
          s: s,
          v: v
        };
      }

      /**
       * Linear interpolation between rgb0 and rgb1.
       * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
       * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
       * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
       * @return {RGBObject} the interpolated color.
       */
    }, {
      key: "mixRgb",
      value: function mixRgb(rgb0, rgb1, fraction1) {
        if (fraction1 <= 0) return rgb0;
        if (fraction1 >= 1) return rgb1;
        var fraction0 = 1 - fraction1;
        return {
          r: fraction0 * rgb0.r + fraction1 * rgb1.r,
          g: fraction0 * rgb0.g + fraction1 * rgb1.g,
          b: fraction0 * rgb0.b + fraction1 * rgb1.b
        };
      }
    }]);
  }();
  color = Color;
  return color;
}

var cast;
var hasRequiredCast;
function requireCast() {
  if (hasRequiredCast) return cast;
  hasRequiredCast = 1;
  var Color = requireColor();

  /**
   * @fileoverview
   * Utilities for casting and comparing Scratch data-types.
   * Scratch behaves slightly differently from JavaScript in many respects,
   * and these differences should be encapsulated below.
   * For example, in Scratch, add(1, join("hello", world")) -> 1.
   * This is because "hello world" is cast to 0.
   * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
   * Use when coercing a value before computation.
   */
  var Cast = /*#__PURE__*/function () {
    function Cast() {
      _classCallCheck(this, Cast);
    }
    return _createClass(Cast, null, [{
      key: "toNumber",
      value:
      /**
       * Scratch cast to number.
       * Treats NaN as 0.
       * In Scratch 2.0, this is captured by `interp.numArg.`
       * @param {*} value Value to cast to number.
       * @return {number} The Scratch-casted number value.
       */
      function toNumber(value) {
        // If value is already a number we don't need to coerce it with
        // Number().
        if (typeof value === 'number') {
          // Scratch treats NaN as 0, when needed as a number.
          // E.g., 0 + NaN -> 0.
          if (Number.isNaN(value)) {
            return 0;
          }
          return value;
        }
        var n = Number(value);
        if (Number.isNaN(n)) {
          // Scratch treats NaN as 0, when needed as a number.
          // E.g., 0 + NaN -> 0.
          return 0;
        }
        return n;
      }

      /**
       * Scratch cast to boolean.
       * In Scratch 2.0, this is captured by `interp.boolArg.`
       * Treats some string values differently from JavaScript.
       * @param {*} value Value to cast to boolean.
       * @return {boolean} The Scratch-casted boolean value.
       */
    }, {
      key: "toBoolean",
      value: function toBoolean(value) {
        // Already a boolean?
        if (typeof value === 'boolean') {
          return value;
        }
        if (typeof value === 'string') {
          // These specific strings are treated as false in Scratch.
          if (value === '' || value === '0' || value.toLowerCase() === 'false') {
            return false;
          }
          // All other strings treated as true.
          return true;
        }
        // Coerce other values and numbers.
        return Boolean(value);
      }

      /**
       * Scratch cast to string.
       * @param {*} value Value to cast to string.
       * @return {string} The Scratch-casted string value.
       */
    }, {
      key: "toString",
      value: function toString(value) {
        return String(value);
      }

      /**
       * Cast any Scratch argument to an RGB color array to be used for the renderer.
       * @param {*} value Value to convert to RGB color array.
       * @return {Array.<number>} [r,g,b], values between 0-255.
       */
    }, {
      key: "toRgbColorList",
      value: function toRgbColorList(value) {
        var color = Cast.toRgbColorObject(value);
        return [color.r, color.g, color.b];
      }

      /**
       * Cast any Scratch argument to an RGB color object to be used for the renderer.
       * @param {*} value Value to convert to RGB color object.
       * @return {RGBOject} [r,g,b], values between 0-255.
       */
    }, {
      key: "toRgbColorObject",
      value: function toRgbColorObject(value) {
        var color;
        if (typeof value === 'string' && value.substring(0, 1) === '#') {
          color = Color.hexToRgb(value);

          // If the color wasn't *actually* a hex color, cast to black
          if (!color) color = {
            r: 0,
            g: 0,
            b: 0,
            a: 255
          };
        } else {
          color = Color.decimalToRgb(Cast.toNumber(value));
        }
        return color;
      }

      /**
       * Determine if a Scratch argument is a white space string (or null / empty).
       * @param {*} val value to check.
       * @return {boolean} True if the argument is all white spaces or null / empty.
       */
    }, {
      key: "isWhiteSpace",
      value: function isWhiteSpace(val) {
        return val === null || typeof val === 'string' && val.trim().length === 0;
      }

      /**
       * Compare two values, using Scratch cast, case-insensitive string compare, etc.
       * In Scratch 2.0, this is captured by `interp.compare.`
       * @param {*} v1 First value to compare.
       * @param {*} v2 Second value to compare.
       * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
       */
    }, {
      key: "compare",
      value: function compare(v1, v2) {
        var n1 = Number(v1);
        var n2 = Number(v2);
        if (n1 === 0 && Cast.isWhiteSpace(v1)) {
          n1 = NaN;
        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
          n2 = NaN;
        }
        if (isNaN(n1) || isNaN(n2)) {
          // At least one argument can't be converted to a number.
          // Scratch compares strings as case insensitive.
          var s1 = String(v1).toLowerCase();
          var s2 = String(v2).toLowerCase();
          if (s1 < s2) {
            return -1;
          } else if (s1 > s2) {
            return 1;
          }
          return 0;
        }
        // Handle the special case of Infinity
        if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
          return 0;
        }
        // Compare as numbers.
        return n1 - n2;
      }

      /**
       * Determine if a Scratch argument number represents a round integer.
       * @param {*} val Value to check.
       * @return {boolean} True if number looks like an integer.
       */
    }, {
      key: "isInt",
      value: function isInt(val) {
        // Values that are already numbers.
        if (typeof val === 'number') {
          if (isNaN(val)) {
            // NaN is considered an integer.
            return true;
          }
          // True if it's "round" (e.g., 2.0 and 2).
          return val === parseInt(val, 10);
        } else if (typeof val === 'boolean') {
          // `True` and `false` always represent integer after Scratch cast.
          return true;
        } else if (typeof val === 'string') {
          // If it contains a decimal point, don't consider it an int.
          return val.indexOf('.') < 0;
        }
        return false;
      }
    }, {
      key: "LIST_INVALID",
      get: function get() {
        return 'INVALID';
      }
    }, {
      key: "LIST_ALL",
      get: function get() {
        return 'ALL';
      }

      /**
       * Compute a 1-based index into a list, based on a Scratch argument.
       * Two special cases may be returned:
       * LIST_ALL: if the block is referring to all of the items in the list.
       * LIST_INVALID: if the index was invalid in any way.
       * @param {*} index Scratch arg, including 1-based numbers or special cases.
       * @param {number} length Length of the list.
       * @param {boolean} acceptAll Whether it should accept "all" or not.
       * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
       */
    }, {
      key: "toListIndex",
      value: function toListIndex(index, length, acceptAll) {
        if (typeof index !== 'number') {
          if (index === 'all') {
            return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
          }
          if (index === 'last') {
            if (length > 0) {
              return length;
            }
            return Cast.LIST_INVALID;
          } else if (index === 'random' || index === 'any') {
            if (length > 0) {
              return 1 + Math.floor(Math.random() * length);
            }
            return Cast.LIST_INVALID;
          }
        }
        index = Math.floor(Cast.toNumber(index));
        if (index < 1 || index > length) {
          return Cast.LIST_INVALID;
        }
        return index;
      }
    }]);
  }();
  cast = Cast;
  return cast;
}

var castExports = requireCast();
var Cast = /*@__PURE__*/getDefaultExportFromCjs(castExports);

var en = {
	"xcxMPHand.name": "Hand Detection",
	"xcxMPHand.startHandDetection": "start hand detection on camera",
	"xcxMPHand.stopHandDetection": "stop hand detection",
	"xcxMPHand.isHandDetecting": "is hand detecting",
	"xcxMPHand.getDetectionIntervalTime": "hand detection interval time",
	"xcxMPHand.setDetectionIntervalTime": "set hand detection interval time to [TIME] ms",
	"videoSensing.setVideoTransparency": "set video transparency to [TRANSPARENCY]",
	"xcxMPHand.numberOfHands": "number of hands",
	"xcxMPHand.handedness": "handedness of hand #[HAND_NUMBER]",
	"xcxMPHand.handLandmarkX": "x of [LANDMARK] of hand #[HAND_NUMBER]",
	"xcxMPHand.handLandmarkY": "y of [LANDMARK] of hand #[HAND_NUMBER]",
	"xcxMPHand.handLandmarkZ": "z of [LANDMARK] of hand #[HAND_NUMBER]",
	"xcxMPHand.handLandmarkRelativeX": "relative x of [LANDMARK] of hand #[HAND_NUMBER]",
	"xcxMPHand.handLandmarkRelativeY": "relative y of [LANDMARK] of hand #[HAND_NUMBER]",
	"xcxMPHand.handLandmarkRelativeZ": "relative z of [LANDMARK] of hand #[HAND_NUMBER]",
	"xcxMPHand.setModelPath": "set model path to [PATH]",
	"xcxMPHand.detectHandOnStage": "detect hand on stage",
	"xcxMPHand.landmarkMenu.wrist": "wrist(0)",
	"xcxMPHand.landmarkMenu.thumbCMC": "thumb CMC(1)",
	"xcxMPHand.landmarkMenu.thumbMCP": "thumb MCP(2)",
	"xcxMPHand.landmarkMenu.thumbIP": "thumb IP(3)",
	"xcxMPHand.landmarkMenu.thumbTip": "thumb tip(4)",
	"xcxMPHand.landmarkMenu.indexFingerMCP": "index finger MCP(5)",
	"xcxMPHand.landmarkMenu.indexFingerPIP": "index finger PIP(6)",
	"xcxMPHand.landmarkMenu.indexFingerDIP": "index finger DIP(7)",
	"xcxMPHand.landmarkMenu.indexFingerTip": "index finger tip(8)",
	"xcxMPHand.landmarkMenu.middleFingerMCP": "middle finger MCP(9)",
	"xcxMPHand.landmarkMenu.middleFingerPIP": "middle finger PIP(10)",
	"xcxMPHand.landmarkMenu.middleFingerDIP": "middle finger DIP(11)",
	"xcxMPHand.landmarkMenu.middleFingerTip": "middle finger tip(12)",
	"xcxMPHand.landmarkMenu.ringFingerMCP": "ring finger MCP(13)",
	"xcxMPHand.landmarkMenu.ringFingerPIP": "ring finger PIP(14)",
	"xcxMPHand.landmarkMenu.ringFingerDIP": "ring finger DIP(15)",
	"xcxMPHand.landmarkMenu.ringFingerTip": "ring finger tip(16)",
	"xcxMPHand.landmarkMenu.pinkyFingerMCP": "pinky finger MCP(17)",
	"xcxMPHand.landmarkMenu.pinkyFingerPIP": "pinky finger PIP(18)",
	"xcxMPHand.landmarkMenu.pinkyFingerDIP": "pinky finger DIP(19)",
	"xcxMPHand.landmarkMenu.pinkyFingerTip": "pinky finger tip(20)"
};
var ja = {
	"xcxMPHand.name": "手の検出",
	"xcxMPHand.startHandDetection": "カメラで手の検出を開始",
	"xcxMPHand.stopHandDetection": "手の検出を停止",
	"xcxMPHand.isHandDetecting": "手を検出しているか",
	"xcxMPHand.getDetectionIntervalTime": "手の検出間隔時間",
	"xcxMPHand.setDetectionIntervalTime": "手の検出間隔時間を[TIME]ミリ秒にする",
	"videoSensing.setVideoTransparency": "ビデオの透明度を[TRANSPARENCY]にする",
	"xcxMPHand.numberOfHands": "手の数",
	"xcxMPHand.handedness": "手#[HAND_NUMBER]が左か右か",
	"xcxMPHand.handLandmarkX": "手#[HAND_NUMBER]の[LANDMARK]のx座標",
	"xcxMPHand.handLandmarkY": "手#[HAND_NUMBER]の[LANDMARK]のy座標",
	"xcxMPHand.handLandmarkZ": "手#[HAND_NUMBER]の[LANDMARK]のz座標",
	"xcxMPHand.handLandmarkRelativeX": "手#[HAND_NUMBER]の[LANDMARK]の相対的なx座標",
	"xcxMPHand.handLandmarkRelativeY": "手#[HAND_NUMBER]の[LANDMARK]の相対的なy座標",
	"xcxMPHand.handLandmarkRelativeZ": "手#[HAND_NUMBER]の[LANDMARK]の相対的なz座標",
	"xcxMPHand.setModelPath": "モデルを[PATH]にする",
	"xcxMPHand.detectHandOnStage": "ステージ上で手を検出",
	"xcxMPHand.landmarkMenu.wrist": "手首(0)",
	"xcxMPHand.landmarkMenu.thumbCMC": "親指のつけ根(1)",
	"xcxMPHand.landmarkMenu.thumbMCP": "親指の第2関節(2)",
	"xcxMPHand.landmarkMenu.thumbIP": "親指の第1関節(3)",
	"xcxMPHand.landmarkMenu.thumbTip": "親指の先端(4)",
	"xcxMPHand.landmarkMenu.indexFingerMCP": "人差し指のつけ根(5)",
	"xcxMPHand.landmarkMenu.indexFingerPIP": "人差し指の第2関節(6)",
	"xcxMPHand.landmarkMenu.indexFingerDIP": "人差し指の第1関節(7)",
	"xcxMPHand.landmarkMenu.indexFingerTip": "人差し指の先端(8)",
	"xcxMPHand.landmarkMenu.middleFingerMCP": "中指のつけ根(9)",
	"xcxMPHand.landmarkMenu.middleFingerPIP": "中指の第2関節(10)",
	"xcxMPHand.landmarkMenu.middleFingerDIP": "中指の第1関節(11)",
	"xcxMPHand.landmarkMenu.middleFingerTip": "中指の先端(12)",
	"xcxMPHand.landmarkMenu.ringFingerMCP": "薬指のつけ根(13)",
	"xcxMPHand.landmarkMenu.ringFingerPIP": "薬指の第2関節(14)",
	"xcxMPHand.landmarkMenu.ringFingerDIP": "薬指の第1関節(15)",
	"xcxMPHand.landmarkMenu.ringFingerTip": "薬指の先端(16)",
	"xcxMPHand.landmarkMenu.pinkyFingerMCP": "小指のつけ根(17)",
	"xcxMPHand.landmarkMenu.pinkyFingerPIP": "小指の第2関節(18)",
	"xcxMPHand.landmarkMenu.pinkyFingerDIP": "小指の第1関節(19)",
	"xcxMPHand.landmarkMenu.pinkyFingerTip": "小指の先端(20)"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"xcxMPHand.name": "て の けんしゅつ",
	"xcxMPHand.startHandDetection": "カメラ で て の けんしゅつ を かいし",
	"xcxMPHand.stopHandDetection": "て の けんしゅつ を ていし",
	"xcxMPHand.isHandDetecting": "て を けんしゅつ しているか",
	"xcxMPHand.getDetectionIntervalTime": "て の けんしゅつ かんかく じかん",
	"xcxMPHand.setDetectionIntervalTime": "て の けんしゅつ かんかく じかん を[TIME]ミリ びょう に する",
	"videoSensing.setVideoTransparency": "ビデオ の とうめいど を[TRANSPARENCY]に する",
	"xcxMPHand.numberOfHands": "て の かず",
	"xcxMPHand.handedness": "て #[HAND_NUMBER]が ひだり か みぎ か",
	"xcxMPHand.handLandmarkX": "て#[HAND_NUMBER]の[LANDMARK]の x ざひょう",
	"xcxMPHand.handLandmarkY": "て#[HAND_NUMBER]の[LANDMARK]の y ざひょう",
	"xcxMPHand.handLandmarkZ": "て#[HAND_NUMBER]の[LANDMARK]の z ざひょう",
	"xcxMPHand.handLandmarkRelativeX": "て#[HAND_NUMBER]の[LANDMARK]の そうたいてきな x ざひょう",
	"xcxMPHand.handLandmarkRelativeY": "て#[HAND_NUMBER]の[LANDMARK]の そうたいてきな y ざひょう",
	"xcxMPHand.handLandmarkRelativeZ": "て#[HAND_NUMBER]の[LANDMARK]の そうたいてきな z ざひょう",
	"xcxMPHand.setModelPath": "モデル を[PATH]に する",
	"xcxMPHand.detectHandOnStage": "ステージ じょう で て を けんしゅつ",
	"xcxMPHand.landmarkMenu.wrist": "てくび (0)",
	"xcxMPHand.landmarkMenu.thumbCMC": "おやゆび の つけね (1)",
	"xcxMPHand.landmarkMenu.thumbMCP": "おやゆび の だい 2 かんせつ (2)",
	"xcxMPHand.landmarkMenu.thumbIP": "おやゆび の だい 1 かんせつ (3)",
	"xcxMPHand.landmarkMenu.thumbTip": "おやゆび の さき (4)",
	"xcxMPHand.landmarkMenu.indexFingerMCP": "ひとさしゆび の つけね (5)",
	"xcxMPHand.landmarkMenu.indexFingerPIP": "ひとさしゆび の だい 2 かんせつ (6)",
	"xcxMPHand.landmarkMenu.indexFingerDIP": "ひとさしゆび の だい 1 かんせつ (7)",
	"xcxMPHand.landmarkMenu.indexFingerTip": "ひとさしゆび の さき (8)",
	"xcxMPHand.landmarkMenu.middleFingerMCP": "なかゆび の つけね (9)",
	"xcxMPHand.landmarkMenu.middleFingerPIP": "なかゆび の だい 2 かんせつ (10)",
	"xcxMPHand.landmarkMenu.middleFingerDIP": "なかゆび の だい 1 かんせつ (11)",
	"xcxMPHand.landmarkMenu.middleFingerTip": "なかゆび の さき (12)",
	"xcxMPHand.landmarkMenu.ringFingerMCP": "くすりゆび の つけね (13)",
	"xcxMPHand.landmarkMenu.ringFingerPIP": "くすりゆび の だい 2 かんせつ (14)",
	"xcxMPHand.landmarkMenu.ringFingerDIP": "くすりゆび の だい 1 かんせつ (15)",
	"xcxMPHand.landmarkMenu.ringFingerTip": "くすりゆび の さき (16)",
	"xcxMPHand.landmarkMenu.pinkyFingerMCP": "こゆび の つけね (17)",
	"xcxMPHand.landmarkMenu.pinkyFingerPIP": "こゆび の だい 2 かんせつ (18)",
	"xcxMPHand.landmarkMenu.pinkyFingerDIP": "こゆび の だい 1 かんせつ (19)",
	"xcxMPHand.landmarkMenu.pinkyFingerTip": "こゆび の さき (20)"
}
};

var img = "data:image/png;base64,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";

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof = {exports: {}};

var hasRequired_typeof;
function require_typeof() {
  if (hasRequired_typeof) return _typeof.exports;
  hasRequired_typeof = 1;
  (function (module) {
    function _typeof(o) {
      "@babel/helpers - typeof";

      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
        return typeof o;
      } : function (o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);
  return _typeof.exports;
}

var hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  if (hasRequiredRegeneratorRuntime) return regeneratorRuntime$1.exports;
  hasRequiredRegeneratorRuntime = 1;
  (function (module) {
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime() {

      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return e;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t,
        e = {},
        r = Object.prototype,
        n = r.hasOwnProperty,
        o = Object.defineProperty || function (t, e, r) {
          t[e] = r.value;
        },
        i = "function" == typeof Symbol ? Symbol : {},
        a = i.iterator || "@@iterator",
        c = i.asyncIterator || "@@asyncIterator",
        u = i.toStringTag || "@@toStringTag";
      function define(t, e, r) {
        return Object.defineProperty(t, e, {
          value: r,
          enumerable: true,
          configurable: true,
          writable: true
        }), t[e];
      }
      try {
        define({}, "");
      } catch (t) {
        define = function define(t, e, r) {
          return t[e] = r;
        };
      }
      function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator,
          a = Object.create(i.prototype),
          c = new Context(n || []);
        return o(a, "_invoke", {
          value: makeInvokeMethod(t, r, c)
        }), a;
      }
      function tryCatch(t, e, r) {
        try {
          return {
            type: "normal",
            arg: t.call(e, r)
          };
        } catch (t) {
          return {
            type: "throw",
            arg: t
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart",
        l = "suspendedYield",
        f = "executing",
        s = "completed",
        y = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var p = {};
      define(p, a, function () {
        return this;
      });
      var d = Object.getPrototypeOf,
        v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t) {
        ["next", "throw", "return"].forEach(function (e) {
          define(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
          var c = tryCatch(t[r], t, o);
          if ("throw" !== c.type) {
            var u = c.arg,
              h = u.value;
            return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
              invoke("next", t, i, a);
            }, function (t) {
              invoke("throw", t, i, a);
            }) : e.resolve(h).then(function (t) {
              u.value = t, i(u);
            }, function (t) {
              return invoke("throw", t, i, a);
            });
          }
          a(c.arg);
        }
        var r;
        o(this, "_invoke", {
          value: function value(t, n) {
            function callInvokeWithMethodAndArg() {
              return new e(function (e, r) {
                invoke(t, n, e, r);
              });
            }
            return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e, r, n) {
        var o = h;
        return function (i, a) {
          if (o === f) throw Error("Generator is already running");
          if (o === s) {
            if ("throw" === i) throw a;
            return {
              value: t,
              done: true
            };
          }
          for (n.method = i, n.arg = a;;) {
            var c = n.delegate;
            if (c) {
              var u = maybeInvokeDelegate(c, n);
              if (u) {
                if (u === y) continue;
                return u;
              }
            }
            if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
              if (o === h) throw o = s, n.arg;
              n.dispatchException(n.arg);
            } else "return" === n.method && n.abrupt("return", n.arg);
            o = f;
            var p = tryCatch(e, r, n);
            if ("normal" === p.type) {
              if (o = n.done ? s : l, p.arg === y) continue;
              return {
                value: p.arg,
                done: n.done
              };
            }
            "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
          }
        };
      }
      function maybeInvokeDelegate(e, r) {
        var n = r.method,
          o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
      }
      function pushTryEntry(t) {
        var e = {
          tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
      }
      function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
      }
      function Context(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e) {
        if (e || "" === e) {
          var r = e[a];
          if (r) return r.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var o = -1,
              i = function next() {
                for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = false, next;
                return next.value = t, next.done = true, next;
              };
            return i.next = i;
          }
        }
        throw new TypeError(_typeof(e) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
      }, e.mark = function (t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
      }, e.awrap = function (t) {
        return {
          __await: t
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
          return t.done ? t.value : a.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
        return this;
      }), define(g, "toString", function () {
        return "[object Generator]";
      }), e.keys = function (t) {
        var e = Object(t),
          r = [];
        for (var n in e) r.push(n);
        return r.reverse(), function next() {
          for (; r.length;) {
            var t = r.pop();
            if (t in e) return next.value = t, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function stop() {
          this.done = true;
          var t = this.tryEntries[0].completion;
          if ("throw" === t.type) throw t.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e) {
          if (this.done) throw e;
          var r = this;
          function handle(n, o) {
            return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
          }
          for (var o = this.tryEntries.length - 1; o >= 0; --o) {
            var i = this.tryEntries[o],
              a = i.completion;
            if ("root" === i.tryLoc) return handle("end");
            if (i.tryLoc <= this.prev) {
              var c = n.call(i, "catchLoc"),
                u = n.call(i, "finallyLoc");
              if (c && u) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              } else if (c) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
              } else {
                if (!u) throw Error("try statement without catch or finally");
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t, e) {
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var o = this.tryEntries[r];
            if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
              var i = o;
              break;
            }
          }
          i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
          var a = i ? i.completion : {};
          return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function complete(t, e) {
          if ("throw" === t.type) throw t.arg;
          return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function finish(t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
          }
        },
        "catch": function _catch(t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.tryLoc === t) {
              var n = r.completion;
              if ("throw" === n.type) {
                var o = n.arg;
                resetTryEntry(r);
              }
              return o;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e, r, n) {
          return this.delegate = {
            iterator: values(e),
            resultName: r,
            nextLoc: n
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);
  return regeneratorRuntime$1.exports;
}

var regenerator;
var hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator) return regenerator;
  hasRequiredRegenerator = 1;
  // TODO(Babel 8): Remove this file.

  var runtime = requireRegeneratorRuntime()();
  regenerator = runtime;

  // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  return regenerator;
}

var regeneratorExports = requireRegenerator();
var _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regeneratorExports);

var vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm');
var modelAssetPath = "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";

/**
 * Create hand landmarker
 * @returns {Promise<HandLandmarker>} - a Promise that resolves with a HandLandmarker instance
 */
var createVideoHandLandmarker = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var marker;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: modelAssetPath,
              delegate: 'GPU'
            },
            runningMode: 'VIDEO',
            numHands: 4
          });
        case 2:
          marker = _context.sent;
          return _context.abrupt("return", marker);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function createVideoHandLandmarker() {
    return _ref.apply(this, arguments);
  };
}();
var videoLandLandmarker = await createVideoHandLandmarker();
var createImageHandLandmarker = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var marker;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: modelAssetPath,
              delegate: 'GPU'
            },
            runningMode: 'IMAGE',
            numHands: 4
          });
        case 2:
          marker = _context2.sent;
          return _context2.abrupt("return", marker);
        case 4:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function createImageHandLandmarker() {
    return _ref2.apply(this, arguments);
  };
}();
var imageLandLandmarker = await createImageHandLandmarker();

/**
 * Detect hands
 * @param {ImageData} image - image data
 * @param {string} runningMode - running mode
 * @returns {HandLandmarkerResult} - hand landmark result
 */
var detect = function detect(_ref3) {
  var image = _ref3.image,
    runningMode = _ref3.runningMode;
  if (runningMode === 'IMAGE') {
    var handLandmarkerResult = imageLandLandmarker.detect(image);
    return handLandmarkerResult;
  } else if (runningMode === 'VIDEO') {
    var startTimeMs = performance.now();
    var _handLandmarkerResult = videoLandLandmarker.detectForVideo(image, startTimeMs);
    return _handLandmarkerResult;
  }
};

/**
 * Set model asset path
 * @param {string} path - model asset path
 */
var setModelAssetPath = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path) {
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          modelAssetPath = path;
          _context3.next = 3;
          return createVideoHandLandmarker();
        case 3:
          videoLandLandmarker = _context3.sent;
          _context3.next = 6;
          return createImageHandLandmarker();
        case 6:
          imageLandLandmarker = _context3.sent;
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function setModelAssetPath(_x) {
    return _ref4.apply(this, arguments);
  };
}();

/**
 * States the video sensing activity can be set to.
 * @readonly
 * @enum {string}
 */
var VideoState = {
  /** Video turned off. */
  OFF: 'off',
  /** Video turned on with default y axis mirroring. */
  ON: 'on',
  /** Video turned on without default y axis mirroring. */
  ON_FLIPPED: 'on-flipped'
};
var Runtime = {
  PROJECT_LOADED: 'PROJECT_LOADED'
};

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.default;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = 'xcxMPHand';

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = 'https://yokobond.github.io/xcx-mp-hand/dist/xcxMPHand.mjs';

/**
 * Scratch 3.0 blocks for example of Xcratch.
 */
var ExtensionBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for MP Hand.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function ExtensionBlocks(runtime) {
    _classCallCheck(this, ExtensionBlocks);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }

    /**
     * A flag to determine if this extension has been installed in a project.
     * It is set to false the first time getInfo is run.
     * @type {boolean}
     */
    this.firstInstall = true;

    /**
     * A flag to determine if hand detection is currently active.
     * @type {boolean}
     */
    this.handDetecting = false;

    /**
     * The detected hands data from MediaPipe hand landmark.
     * @type {object?}
     */
    this.hands = null;

    /**
     * The interval ID for the detection loop.
     * @type {number}
     */
    this.detectionInterval = null;

    /**
     * The interval time for the detection loop in milliseconds.
     * @type {number}
     */
    this.detectionIntervalTime = 100;
    if (this.runtime.ioDevices) {
      // Configure the video device with values from globally stored locations.
      this.runtime.on(Runtime.PROJECT_LOADED, this.updateVideoDisplay.bind(this));
    }
  }

  /**
   * The transparency setting of the video preview stored in a value
   * accessible by any object connected to the virtual machine.
   * @type {number}
   */
  return _createClass(ExtensionBlocks, [{
    key: "globalVideoTransparency",
    get: function get() {
      var stage = this.runtime.getTargetForStage();
      if (stage) {
        return stage.videoTransparency;
      }
      return 50;
    },
    set: function set(transparency) {
      var stage = this.runtime.getTargetForStage();
      if (stage) {
        stage.videoTransparency = transparency;
      }
    }

    /**
     * The video state of the video preview stored in a value accessible by any
     * object connected to the virtual machine.
     * @type {number}
     */
  }, {
    key: "globalVideoState",
    get: function get() {
      var stage = this.runtime.getTargetForStage();
      if (stage) {
        return stage.videoState;
      }
      // Though the default value for the stage is normally 'on', we need to default
      // to 'off' here to prevent the video device from briefly activating
      // while waiting for stage targets to be installed that say it should be off
      return VideoState.OFF;
    },
    set: function set(state) {
      var stage = this.runtime.getTargetForStage();
      if (stage) {
        stage.videoState = state;
      }
    }

    /**
     * An array of info on video state options for the "turn video [STATE]" block.
     * @type {object[]}
     * @param {string} name - the translatable name to display in the video state menu
     * @param {string} value - the serializable value stored in the block
     */
  }, {
    key: "VIDEO_STATE_INFO",
    get: function get() {
      return [{
        name: formatMessage({
          id: 'videoSensing.off',
          default: 'off',
          description: 'Option for the "turn video [STATE]" block'
        }),
        value: VideoState.OFF
      }, {
        name: formatMessage({
          id: 'videoSensing.on',
          default: 'on',
          description: 'Option for the "turn video [STATE]" block'
        }),
        value: VideoState.ON
      }, {
        name: formatMessage({
          id: 'videoSensing.onFlipped',
          default: 'on flipped',
          description: 'Option for the "turn video [STATE]" block that causes the video to be flipped' + ' horizontally (reversed as in a mirror)'
        }),
        value: VideoState.ON_FLIPPED
      }];
    }

    /**
     * Create data for a menu in scratch-blocks format, consisting of an array
     * of objects with text and value properties. The text is a translated
     * string, and the value is one-indexed.
     * @param {object[]} info - An array of info objects each having a name
     *   property.
     * @return {array} - An array of objects with text and value properties.
     * @private
     */
  }, {
    key: "_buildMenu",
    value: function _buildMenu(info) {
      return info.map(function (entry, index) {
        var obj = {};
        obj.text = entry.name;
        obj.value = entry.value || String(index + 1);
        return obj;
      });
    }

    /**
     * Get the latest values for video transparency and state,
     * and set the video device to use them.
     */
  }, {
    key: "updateVideoDisplay",
    value: function updateVideoDisplay() {
      this.setVideoTransparency({
        TRANSPARENCY: this.globalVideoTransparency
      });
      this.videoToggle({
        VIDEO_STATE: this.globalVideoState
      });
    }
  }, {
    key: "getLandmarkMenu",
    value: function getLandmarkMenu() {
      var landmarks = [{
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.wrist',
          default: 'wrist(0)'
        }),
        value: '0'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.thumbCMC',
          default: 'thumb CMC(1)'
        }),
        value: '1'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.thumbMCP',
          default: 'thumb MCP(2)'
        }),
        value: '2'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.thumbIP',
          default: 'thumb IP(3)'
        }),
        value: '3'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.thumbTip',
          default: 'thumb tip(4)'
        }),
        value: '4'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.indexFingerMCP',
          default: 'index finger MCP(5)'
        }),
        value: '5'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.indexFingerPIP',
          default: 'index finger PIP(6)'
        }),
        value: '6'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.indexFingerDIP',
          default: 'index finger DIP(7)'
        }),
        value: '7'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.indexFingerTip',
          default: 'index finger tip(8)'
        }),
        value: '8'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.middleFingerMCP',
          default: 'middle finger MCP(9)'
        }),
        value: '9'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.middleFingerPIP',
          default: 'middle finger PIP(10)'
        }),
        value: '10'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.middleFingerDIP',
          default: 'middle finger DIP(11)'
        }),
        value: '11'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.middleFingerTip',
          default: 'middle finger tip(12)'
        }),
        value: '12'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.ringFingerMCP',
          default: 'ring finger MCP(13)'
        }),
        value: '13'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.ringFingerPIP',
          default: 'ring finger PIP(14)'
        }),
        value: '14'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.ringFingerDIP',
          default: 'ring finger DIP(15)'
        }),
        value: '15'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.ringFingerTip',
          default: 'ring finger tip(16)'
        }),
        value: '16'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.pinkyFingerMCP',
          default: 'pinky finger MCP(17)'
        }),
        value: '17'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.pinkyFingerPIP',
          default: 'pinky finger PIP(18)'
        }),
        value: '18'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.pinkyFingerDIP',
          default: 'pinky finger DIP(19)'
        }),
        value: '19'
      }, {
        text: formatMessage({
          id: 'xcxMPHand.landmarkMenu.pinkyFingerTip',
          default: 'pinky finger tip(20)'
        }),
        value: '20'
      }];
      return landmarks;
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
  }, {
    key: "getInfo",
    value: function getInfo() {
      // Set the video display properties to defaults the first time
      // getInfo is run. This turns on the video device when it is
      // first added to a project, and is overwritten by a PROJECT_LOADED
      // event listener that later calls updateVideoDisplay
      if (this.firstInstall) {
        this.globalVideoState = VideoState.OFF;
        this.globalVideoTransparency = 50;
        this.updateVideoDisplay();
        this.firstInstall = false;
      }
      setupTranslations();
      return {
        id: ExtensionBlocks.EXTENSION_ID,
        name: ExtensionBlocks.EXTENSION_NAME,
        extensionURL: ExtensionBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: false,
        blocks: [{
          opcode: 'startHandDetection',
          blockType: BlockType.COMMAND,
          text: formatMessage({
            id: 'xcxMPHand.startHandDetection',
            default: 'start hand detection on camera',
            description: 'start hand detection on video camera'
          }),
          arguments: {}
        }, {
          opcode: 'stopHandDetection',
          blockType: BlockType.COMMAND,
          text: formatMessage({
            id: 'xcxMPHand.stopHandDetection',
            default: 'stop hand detection'
          })
        }, {
          opcode: 'isHandDetecting',
          blockType: BlockType.BOOLEAN,
          text: formatMessage({
            id: 'xcxMPHand.isHandDetecting',
            default: 'is hand detecting'
          })
        }, {
          opcode: 'getDetectionIntervalTime',
          blockType: BlockType.REPORTER,
          disableMonitor: true,
          text: formatMessage({
            id: 'xcxMPHand.getDetectionIntervalTime',
            default: 'hand detection interval time'
          })
        }, {
          opcode: 'setDetectionIntervalTime',
          blockType: BlockType.COMMAND,
          text: formatMessage({
            id: 'xcxMPHand.setDetectionIntervalTime',
            default: 'set hand detection interval time to [TIME] ms'
          }),
          arguments: {
            TIME: {
              type: ArgumentType.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'setVideoTransparency',
          blockType: BlockType.COMMAND,
          text: formatMessage({
            id: 'videoSensing.setVideoTransparency',
            default: 'set video transparency to [TRANSPARENCY]',
            description: 'Controls transparency of the video preview layer'
          }),
          arguments: {
            TRANSPARENCY: {
              type: ArgumentType.NUMBER,
              defaultValue: 50
            }
          }
        }, '---', {
          opcode: 'detectHandOnStage',
          blockType: BlockType.COMMAND,
          text: formatMessage({
            id: 'xcxMPHand.detectHandOnStage',
            default: 'detect hand on stage'
          })
        }, '---', {
          opcode: 'numberOfHands',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.numberOfHands',
            default: 'number of hands'
          })
        }, {
          opcode: 'handedness',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handedness',
            default: 'handedness of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            }
          }
        }, {
          opcode: 'handLandmarkX',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handLandmarkX',
            default: 'x of [LANDMARK] of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            LANDMARK: {
              type: ArgumentType.STRING,
              menu: 'LANDMARK'
            }
          }
        }, {
          opcode: 'handLandmarkY',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handLandmarkY',
            default: 'y of [LANDMARK] of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            LANDMARK: {
              type: ArgumentType.STRING,
              menu: 'LANDMARK'
            }
          }
        }, {
          opcode: 'handLandmarkZ',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handLandmarkZ',
            default: 'z of [LANDMARK] of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            LANDMARK: {
              type: ArgumentType.STRING,
              menu: 'LANDMARK'
            }
          }
        }, '---', {
          opcode: 'handLandmarkRelativeX',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handLandmarkRelativeX',
            default: 'relative x of [LANDMARK] of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            LANDMARK: {
              type: ArgumentType.STRING,
              menu: 'LANDMARK'
            }
          }
        }, {
          opcode: 'handLandmarkRelativeY',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handLandmarkRelativeY',
            default: 'relative y of [LANDMARK] of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            LANDMARK: {
              type: ArgumentType.STRING,
              menu: 'LANDMARK'
            }
          }
        }, {
          opcode: 'handLandmarkRelativeZ',
          blockType: BlockType.REPORTER,
          text: formatMessage({
            id: 'xcxMPHand.handLandmarkRelativeZ',
            default: 'relative z of [LANDMARK] of hand #[HAND_NUMBER]'
          }),
          arguments: {
            HAND_NUMBER: {
              type: ArgumentType.NUMBER,
              defaultValue: 1
            },
            LANDMARK: {
              type: ArgumentType.STRING,
              menu: 'LANDMARK'
            }
          }
        }, '---', {
          opcode: 'setModelPath',
          blockType: BlockType.COMMAND,
          text: formatMessage({
            id: 'xcxMPHand.setModelPath',
            default: 'set model path to [PATH]'
          }),
          arguments: {
            PATH: {
              type: ArgumentType.STRING,
              defaultValue: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
            }
          }
        }],
        menus: {
          LANDMARK: {
            acceptReporters: true,
            items: 'getLandmarkMenu'
          },
          VIDEO_STATE: {
            acceptReporters: false,
            items: this._buildMenu(this.VIDEO_STATE_INFO)
          }
        }
      };
    }

    /**
     * A scratch command block handle that configures the video state from
     * passed arguments.
     * @param {object} args - the block arguments
     * @param {VideoState} args.VIDEO_STATE - the video state to set the device to
     */
  }, {
    key: "videoToggle",
    value: function videoToggle(args) {
      var state = args.VIDEO_STATE;
      this.globalVideoState = state;
      if (state === VideoState.OFF) {
        this.runtime.ioDevices.video.disableVideo();
      } else {
        this.runtime.ioDevices.video.enableVideo();
        // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.
        this.runtime.ioDevices.video.mirror = state === VideoState.ON;
      }
    }

    /**
     * A scratch command block handle that configures the video preview's
     * transparency from passed arguments.
     * @param {object} args - the block arguments
     * @param {number} args.TRANSPARENCY - the transparency to set the video
     *   preview to
     */
  }, {
    key: "setVideoTransparency",
    value: function setVideoTransparency(args) {
      var transparency = Cast.toNumber(args.TRANSPARENCY);
      this.globalVideoTransparency = transparency;
      this.runtime.ioDevices.video.setPreviewGhost(transparency);
    }

    /**
     * Start hand detection with the specified video state.
     */
  }, {
    key: "startHandDetection",
    value: function startHandDetection() {
      var _this = this;
      // Turn on the video if it is off
      var state = this.globalVideoState;
      if (state === VideoState.OFF) {
        this.runtime.ioDevices.video.enableVideo();
        // Mirror the video for hand detection
        this.runtime.ioDevices.video.mirror = true;
      }
      if (this.handDetecting) {
        return;
      }

      // Start the detection loop
      this.handDetecting = true;
      var _detectFrame = function detectFrame() {
        if (!_this.handDetecting) {
          return;
        }

        // Get the current video frame
        var image = _this.runtime.ioDevices.video.getFrame('image-data', [480, 360]);
        if (!image) {
          _this.detectionInterval = setTimeout(_detectFrame, _this.detectionIntervalTime);
          return;
        }
        // Send the frame to the hand detection model
        var result = detect({
          image: image,
          runningMode: 'VIDEO'
        });
        if (!result.handednesses || !result.handednesses[0]) {
          _this.hands = null;
        } else {
          _this.hands = result;
        }

        // Schedule next detection
        _this.detectionInterval = setTimeout(_detectFrame, _this.detectionIntervalTime);
      };

      // Start the detection loop
      this.detectionInterval = setTimeout(_detectFrame, this.detectionIntervalTime);
    }

    /**
     * Stop hand detection.
     */
  }, {
    key: "stopHandDetection",
    value: function stopHandDetection() {
      this.handDetecting = false;
      if (this.detectionInterval) {
        clearInterval(this.detectionInterval);
        this.detectionInterval = null;
      }

      // Clear the hands data
      this.hands = [];
    }

    /**
     * Check if hand detection is currently active.
     * @returns {boolean} - true if hand detection is active
     */
  }, {
    key: "isHandDetecting",
    value: function isHandDetecting() {
      return this.handDetecting;
    }

    /**
     * Get the interval time for the detection loop.
     * @returns {number} - the interval time in milliseconds
     */
  }, {
    key: "getDetectionIntervalTime",
    value: function getDetectionIntervalTime() {
      return this.detectionIntervalTime;
    }

    /**
     * Set the interval time for the detection loop.
     * @param {object} args - the block arguments
     * @param {number} args.TIME - the interval time in milliseconds
     */
  }, {
    key: "setDetectionIntervalTime",
    value: function setDetectionIntervalTime(args) {
      var time = Cast.toNumber(args.TIME);
      this.detectionIntervalTime = Math.max(0, time);
    }

    /**
     * Detect hand on the stage.
     * @returns {Promise} - a promise that resolves when the hand is detected
     */
  }, {
    key: "detectHandOnStage",
    value: function detectHandOnStage() {
      var _this2 = this;
      return new Promise(function (resolve) {
        _this2.runtime.renderer.requestSnapshot(function (imageDataURL) {
          var image = new Image();
          image.onload = function () {
            var canvas = document.createElement('canvas');
            canvas.width = 480;
            canvas.height = 360;
            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, 480, 360);
            var imageData = context.getImageData(0, 0, 480, 360);
            var result = detect({
              image: imageData,
              runningMode: 'IMAGE'
            });
            _this2.hands = result;
            resolve('Hand detected');
          };
          image.src = imageDataURL;
        });
      });
    }

    /**
     * Get the number of detected hands.
     * @returns {number} - the number of detected hands
     */
  }, {
    key: "numberOfHands",
    value: function numberOfHands() {
      if (!this.hands || !this.hands.handednesses) {
        return 0;
      }
      return this.hands.handednesses.length;
    }

    /**
     * Get the landmark data of a specific landmark on a specific hand.
     * @param {number} handIndex - the hand index (0-based)
     * @param {number} landmarkIndex - the landmark index (0-20)
     * @returns {object} - the landmark data
     */
  }, {
    key: "handLandmark",
    value: function handLandmark(handIndex, landmarkIndex) {
      if (!this.hands || !this.hands.handednesses) {
        return null;
      }

      // Check if the hand and landmark exist
      if (handIndex < 0 || handIndex >= this.hands.handednesses.length) return null;
      if (landmarkIndex < 0 || landmarkIndex > 20) return null; // MediaPipe hand has 21 landmarks (0-20)

      return this.hands.landmarks[handIndex][landmarkIndex];
    }

    /**
     * Get the X coordinate of a specific landmark on a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @param {number} args.LANDMARK - the landmark index (0-20)
     * @returns {number} - the X coordinate of the landmark
     */
  }, {
    key: "handLandmarkX",
    value: function handLandmarkX(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      var landmarkIndex = Cast.toNumber(args.LANDMARK);
      var landmark = this.handLandmark(handIndex, landmarkIndex);
      if (!landmark) return 0;

      // Convert the x coordinate to Scratch coordinate system (center is 0,0, right is positive)
      // MediaPipe coordinates are normalized (0-1) where 0 is left, 1 is right
      var x = (landmark.x - 0.5) * 480; // Scale to Scratch stage width
      return x;
    }

    /**
     * Get the Y coordinate of a specific landmark on a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @param {number} args.LANDMARK - the landmark index (0-20)
     * @returns {number} - the Y coordinate of the landmark
     */
  }, {
    key: "handLandmarkY",
    value: function handLandmarkY(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      var landmarkIndex = Cast.toNumber(args.LANDMARK);
      var landmark = this.handLandmark(handIndex, landmarkIndex);
      if (!landmark) return 0;

      // Convert the y coordinate to Scratch coordinate system (center is 0,0, up is positive)
      // MediaPipe coordinates are normalized (0-1) where 0 is top, 1 is bottom
      var y = (0.5 - landmark.y) * 360; // Scale to Scratch stage height and invert

      return y;
    }

    /**
     * Get the Z coordinate of a specific landmark on a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @param {number} args.LANDMARK - the landmark index (0-20)
     * @returns {number} - the Z coordinate of the landmark
     */
  }, {
    key: "handLandmarkZ",
    value: function handLandmarkZ(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      var landmarkIndex = Cast.toNumber(args.LANDMARK);
      var landmark = this.handLandmark(handIndex, landmarkIndex);
      if (!landmark) return 0;

      // Z is depth, with negative values being closer to the camera
      // Scale the z value to make it more usable in Scratch
      return landmark.z * 200;
    }

    /**
     * Get the handedness of a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @returns {string} - the handedness of the hand
     */
  }, {
    key: "handedness",
    value: function handedness(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      if (!this.hands || !this.hands.handednesses) {
        return ' ';
      }
      if (handIndex < 0 || handIndex >= this.hands.handednesses.length) {
        return ' ';
      }
      return this.hands.handednesses[handIndex][0].categoryName;
    }

    /**
     * Get the relative landmark data of a specific landmark on a specific hand.
     * @param {number} handIndex - the hand index (0-based)
     * @param {number} landmarkIndex - the landmark index (0-20)
     * @returns {object} - the landmark data
     */
  }, {
    key: "handLandmarkRelative",
    value: function handLandmarkRelative(handIndex, landmarkIndex) {
      if (!this.hands || !this.hands.handednesses) {
        return null;
      }

      // Check if the hand and landmark exist
      if (handIndex < 0 || handIndex >= this.hands.handednesses.length) return null;
      if (landmarkIndex < 0 || landmarkIndex > 20) return null; // MediaPipe hand has 21 landmarks (0-20)

      return this.hands.worldLandmarks[handIndex][landmarkIndex];
    }

    /**
     * Get the relative X coordinate of a specific landmark on a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @param {number} args.LANDMARK - the landmark index (0-20)
     * @returns {number} - the relative X coordinate of the landmark
     */
  }, {
    key: "handLandmarkRelativeX",
    value: function handLandmarkRelativeX(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      var landmarkIndex = Cast.toNumber(args.LANDMARK);
      var landmark = this.handLandmarkRelative(handIndex, landmarkIndex);
      if (!landmark) return 0;
      return landmark.x;
    }

    /**
     * Get the relative Y coordinate of a specific landmark on a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @param {number} args.LANDMARK - the landmark index (0-20)
     * @returns {number} - the relative Y coordinate of the landmark
     */
  }, {
    key: "handLandmarkRelativeY",
    value: function handLandmarkRelativeY(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      var landmarkIndex = Cast.toNumber(args.LANDMARK);
      var landmark = this.handLandmarkRelative(handIndex, landmarkIndex);
      if (!landmark) return 0;
      // Invert the y coordinate for Scratch coordinate system (up is positive)
      return -landmark.y;
    }

    /**
     * Get the relative Z coordinate of a specific landmark on a specific hand.
     * @param {object} args - the block arguments
     * @param {number} args.HAND_NUMBER - the hand index (1-based)
     * @param {number} args.LANDMARK - the landmark index (0-20)
     * @returns {number} - the relative Z coordinate of the landmark
     */
  }, {
    key: "handLandmarkRelativeZ",
    value: function handLandmarkRelativeZ(args) {
      var handIndex = Cast.toNumber(args.HAND_NUMBER) - 1; // Convert to 0-based index
      var landmarkIndex = Cast.toNumber(args.LANDMARK);
      var landmark = this.handLandmarkRelative(handIndex, landmarkIndex);
      if (!landmark) return 0;
      return landmark.z;
    }

    /**
     * Set the model asset path for hand detection.
     * @param {object} args - the block arguments
     * @param {string} args.PATH - the model asset path
     * @returns {Promise} - a promise that resolve when the model set
     */
  }, {
    key: "setModelPath",
    value: function setModelPath(args) {
      var path = Cast.toString(args.PATH).trim();
      if (!path) return;
      return setModelAssetPath(path).then(function () {
        return 'Model asset path set successfully';
      }).catch(function (e) {
        console.error(e);
        return e.message;
      });
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }

    /**
     * @return {string} - the name of this extension.
     */
  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'xcxMPHand.name',
        default: 'Hand Detection',
        description: 'name of the extension'
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }
  }]);
}();

export { ExtensionBlocks as blockClass, entry };
//# sourceMappingURL=xcxMPHand.mjs.map
